diff --git a/mereproof/contracts/token.ral b/mereproof/contracts/token.ral
deleted file mode 100644
index 580e5b5..0000000
--- a/mereproof/contracts/token.ral
+++ /dev/null
@@ -1,69 +0,0 @@
-import "std/fungible_token_interface"
-
-// Defines a contract named `TokenFaucet`.
-// A contract is a collection of fields (its state) and functions.
-// Once deployed, a contract resides at a specific address on the Alephium blockchain.
-// Contract fields are permanently stored in contract storage.
-// A contract can issue an initial amount of token at its deployment.
-Contract TokenFaucet(
-    symbol: ByteVec,
-    name: ByteVec,
-    decimals: U256,
-    supply: U256,
-    mut balance: U256
-) implements IFungibleToken {
-
-    // Events allow for logging of activities on the blockchain.
-    // Alephium clients can listen to events in order to react to contract state changes.
-    event Withdraw(to: Address, amount: U256)
-
-    enum ErrorCodes {
-        InvalidWithdrawAmount = 0
-    }
-
-    // A public function that returns the initial supply of the contract's token.
-    // Note that the field must be initialized as the amount of the issued token.
-    pub fn getTotalSupply() -> U256 {
-        return supply
-    }
-
-    // A public function that returns the symbol of the token.
-    pub fn getSymbol() -> ByteVec {
-        return symbol
-    }
-
-    // A public function that returns the name of the token.
-    pub fn getName() -> ByteVec {
-        return name
-    }
-
-    // A public function that returns the decimals of the token.
-    pub fn getDecimals() -> U256 {
-        return decimals
-    }
-
-    // A public function that returns the current balance of the contract.
-    pub fn balance() -> U256 {
-        return balance
-    }
-
-    // A public function that transfers tokens to anyone who calls it.
-    // The function is annotated with `updateFields = true` as it changes the contract fields.
-    // The function is annotated as using contract assets as it does.
-    // The function is annotated with `checkExternalCaller = false` as there is no need to check the external caller.
-    @using(assetsInContract = true, updateFields = true, checkExternalCaller = false)
-    pub fn withdraw(amount: U256) -> () {
-        // Debug events can be helpful for error analysis
-        emit Debug(`The current balance is ${balance}`)
-
-        // Make sure the amount is valid
-        assert!(amount <= 2, ErrorCodes.InvalidWithdrawAmount)
-        // Functions postfixed with `!` are built-in functions.
-        transferTokenFromSelf!(callerAddress!(), selfTokenId!(), amount)
-        // Ralph does not allow underflow.
-        balance = balance - amount
-
-        // Emit the event defined earlier.
-        emit Withdraw(callerAddress!(), amount)
-    }
-}
diff --git a/mereproof/contracts/withdraw.ral b/mereproof/contracts/withdraw.ral
deleted file mode 100644
index c54ba1a..0000000
--- a/mereproof/contracts/withdraw.ral
+++ /dev/null
@@ -1,8 +0,0 @@
-// Defines a transaction script.
-// A transaction script is a piece of code to interact with contracts on the blockchain.
-// Transaction scripts can use the input assets of transactions in general.
-// A script is disposable and will only be executed once along with the holder transaction.
-TxScript Withdraw(token: TokenFaucet, amount: U256) {
-    // Call token contract's withdraw function.
-    token.withdraw(amount)
-}
diff --git a/mereproof/next.config.js b/mereproof/next.config.js
index 3c0e22e..ff4a58c 100644
--- a/mereproof/next.config.js
+++ b/mereproof/next.config.js
@@ -1,5 +1,7 @@
 /** @type {import('next').NextConfig} */
 const nextConfig = {
+  output: "standalone",
+  productionBrowserSourceMaps: true,
   reactStrictMode: true,
   webpack: (config, { isServer }) => {
     if (!isServer) {
diff --git a/mereproof/scripts/0_deploy_faucet.ts b/mereproof/scripts/0_deploy_faucet.ts
deleted file mode 100644
index 3d1fa6f..0000000
--- a/mereproof/scripts/0_deploy_faucet.ts
+++ /dev/null
@@ -1,29 +0,0 @@
-import { Deployer, DeployFunction, Network } from '@alephium/cli'
-import { Settings } from '../alephium.config'
-import { TokenFaucet } from '../artifacts/ts'
-
-// This deploy function will be called by cli deployment tool automatically
-// Note that deployment scripts should prefixed with numbers (starting from 0)
-const deployFaucet: DeployFunction<Settings> = async (
-  deployer: Deployer,
-  network: Network<Settings>
-): Promise<void> => {
-  // Get settings
-  const issueTokenAmount = network.settings.issueTokenAmount
-  const result = await deployer.deployContract(TokenFaucet, {
-    // The amount of token to be issued
-    issueTokenAmount: issueTokenAmount,
-    // The initial states of the faucet contract
-    initialFields: {
-      symbol: Buffer.from('TF', 'utf8').toString('hex'),
-      name: Buffer.from('TokenFaucet', 'utf8').toString('hex'),
-      decimals: 0n,
-      supply: issueTokenAmount,
-      balance: issueTokenAmount
-    }
-  })
-  console.log('Token faucet contract id: ' + result.contractInstance.contractId)
-  console.log('Token faucet contract address: ' + result.contractInstance.address)
-}
-
-export default deployFaucet
diff --git a/mereproof/src/components/DropZone.tsx b/mereproof/src/components/DropZone.tsx
new file mode 100644
index 0000000..1c24b44
--- /dev/null
+++ b/mereproof/src/components/DropZone.tsx
@@ -0,0 +1,278 @@
+/*
+import React, { useState, ChangeEvent, useCallback } from 'react'
+import { useDropzone } from 'react-dropzone'
+import blake from 'blakejs'
+import { HexString } from '@alephium/web3'
+import { BsExclamationCircle, BsTrash } from "react-icons/bs";
+
+declare module "react" {
+    interface InputHTMLAttributes<T> extends HTMLAttributes<T> {
+        webkitdirectory?: string
+        directory?: string
+    }
+}
+
+interface MerkleProof {
+    hashType: string
+    root: string
+    hash: string
+    operations: Array<Operation>
+    anchors: Array<Anchor>
+    date: string
+}
+
+interface Operation {
+    left?: string
+    right?: string
+}
+
+interface Anchor {
+    type: string
+    networkId: number
+    transactionId: string
+    blockId: string
+    blockDate: string
+}
+
+interface FileItem {
+    name: string
+}
+
+interface myFileItem extends FileItem {
+    hashType?: string
+    hash?: HexString
+    proof?: MerkleProof
+    pairedWith?: FileItem
+    isSibling?: boolean
+}
+
+enum modes {
+    Validate = "Validate",
+    Anchor = "Anchor",
+    Undefined = 0
+}
+
+const hashFunction = {
+    blake2b_256: (buf: Uint8Array): string => { return blake.blake2sHex(buf, undefined, 32) }
+}
+
+export const DropZone = () => {
+
+    const [files, setFiles] = useState<FileItem[]>([])
+
+    const [mode, setMode] = useState<modes>(modes.Undefined)
+
+    const [ready, setReady] = useState<boolean>(false)
+
+    const updateAll = (): void => {
+
+        updateMode();
+        updateReady();
+    }
+
+    // auto-switch between validation and anchoring
+    const updateMode = (): void => {
+        var _mode: modes = modes.Anchor;
+        // if there is one proof, assume we are validating
+        (files as myFileItem[]).some((file) => {
+            if (file.proof) {
+                _mode = modes.Validate;
+                return true;
+
+            }
+        })
+        if (mode != _mode)
+            setMode(_mode)
+    }
+
+    // check if we are ready to anchor or validate something
+    const updateReady = (): void => {
+        // if there is no proof we are ready to anchor
+        var weAreReady: boolean = (files.length > 0);
+
+        // if there is an orphan proof we are not ready to validate
+        if (mode != modes.Anchor) {
+            (files as myFileItem[]).some((file) => {
+                if (!file.pairedWith) {
+                    weAreReady = false
+                    return true
+                }
+            })
+        }
+        if (ready != weAreReady)
+            setReady(weAreReady)
+    }
+
+    const computeHash = (file: myFileItem, content: ArrayBuffer) => {
+        file.hashType = 'blake2s'
+        if (!file.hash)
+            switch (file.hashType) {
+                case 'blake2s': file.hash = blake.blake2sHex(new Uint8Array(content)); break
+            }
+        // new Uint8Array(content as ArrayBuffer)
+    }
+
+    const associateTextFileWithSibling = (textFile: myFileItem): void => {
+        (files as myFileItem[]).some((file) => {
+            var proof = file.proof;
+            if (proof && proof.hashType == textFile.hashType && proof.operations && proof.operations[0].right && proof.operations[0].right == textFile.hash) {
+                textFile.pairedWith = file
+                textFile.isSibling = true
+            }
+        })
+    }
+
+    const associateFileWithProof = (lonelyFile: myFileItem): void => {
+        (files as myFileItem[]).some((file) => {
+            var proof = file.proof
+            if (proof && proof.hashType && proof.hashType == lonelyFile.hashType && proof.hash && proof.hash == lonelyFile.hash) {
+                lonelyFile.pairedWith = file
+                file.pairedWith = lonelyFile
+                return true
+            }
+        })
+    }
+
+    const associateProofWithFile = (orphanProof: myFileItem): void => {
+        (files as myFileItem[]).some((file) => {
+            if (!file.proof && orphanProof.proof && file.hashType == orphanProof.proof.hashType && file.hash == orphanProof.hash) {
+                orphanProof.pairedWith = file
+                file.pairedWith = orphanProof
+                return true
+            }
+        })
+    }
+
+    const proofOrNothing = (proof: MerkleProof): MerkleProof | undefined => {
+        if (proof.root && proof.hashType && proof.hash && proof.date && proof.operations && proof.operations.length && proof.anchors && proof.anchors.length) {
+            return proof;
+        }
+    }
+
+    const processFileListItem = (file: FileItem, content: string | ArrayBuffer | undefined): FileItem => {
+        var fileItem = (file as myFileItem)
+        if (fileItem.name.match(/.json$/i)) {
+            // file is a json, try to parse it once
+            // fileItem.proof = fileItem.proof || content && proofOrNothing(JSON.parse(String.fromCharCode.apply(null, new Uint8Array(content as ArrayBufferLike) as unknown as number[])) as MerkleProof) || undefined
+            fileItem.proof = fileItem.proof || content && proofOrNothing(JSON.parse(content as string) as MerkleProof) || undefined
+        }
+        if (fileItem.proof) {
+            // file is a proof
+            // try to associate the proof with a file
+            associateProofWithFile(fileItem)
+            setMode(modes.Validate)
+
+        } else {
+            // file is not a proof
+            computeHash(fileItem, content as ArrayBuffer)
+            // try to associate the file with a proof
+            associateFileWithProof(fileItem)
+
+            if (fileItem.name.match(/(.*).txt$/i)) {
+                // try to associate the text file with a sibling
+                associateTextFileWithSibling(fileItem)
+            }
+        }
+        return fileItem;
+    }
+
+    const onDrop = useCallback((acceptedFiles: File[]) => {
+        var remaining: number = acceptedFiles.length;
+
+        acceptedFiles.forEach((file: File) => {
+            const reader = new FileReader()
+
+            reader.onabort = () => {
+                console.log('file reading was aborted')
+            }
+            reader.onerror = () => {
+                console.log('file reading has failed')
+            }
+            reader.onload = (e: ProgressEvent<FileReader>) => {
+                e.target && e.target.result &&
+                    setFiles((files) => [...files, processFileListItem({
+                        name: file.name
+                    }, e.target && e.target.result || undefined)])
+            }
+            reader.onloadend = () => {
+                --remaining
+                if (!remaining) {
+                    updateAll();
+                    if (ready == true) {
+                        if (mode == modes.Validate)
+                            DoValidate()
+                    }
+                }
+            }
+            if (file.name.match(/\.json$/i))
+                reader.readAsText(file)
+            else
+                reader.readAsArrayBuffer(file)
+        })
+
+    }, [])
+
+    const { getRootProps, getInputProps } = useDropzone({ onDrop })
+    const getClassName = (file: myFileItem): string => {
+        updateMode();
+        var classList: string[] = []
+        if (mode == modes.Validate) {
+            if (!file.pairedWith)
+                classList.push("unpaired")
+            if (file.proof)
+                classList.push("proof")
+            else
+                classList.push("file")
+            if (file.isSibling)
+                classList.push("sibling")
+
+        } else {
+
+        }
+        return classList.join(' ')
+        console.log('here')
+    }
+
+    const clear = () => {
+        setFiles([])
+        setMode(modes.Undefined)
+    }
+
+    const abortClick = (e: React.MouseEvent<HTMLElement>): boolean => {
+        e.stopPropagation()
+        return false;
+    }
+
+    return (
+        <div className="DropZone">
+            <div {...getRootProps()}>
+                <input {...getInputProps()} multiple />
+                <p>Drag 'n' drop some files here, or click to select files</p>
+            {files.length > 0 && (
+                <div onClick={abortClick}>
+                    <h3>Selected Files:</h3>
+                    <ul className="dropzone">
+                        {(files as myFileItem[]).map((file, index) => (
+                            <li key={index} className={getClassName(file)}>
+                                <BsExclamationCircle className="unpaired" title="Proof has matching file !"></BsExclamationCircle>
+                                <BsExclamationCircle className="unpaired" title="File has no matching proof !"></BsExclamationCircle>
+                                <BsTrash className="trash"></BsTrash>
+                                <span>{file.name}</span>
+                                <span>{file.hash}</span>
+                           </li>
+                        ))}
+                    </ul>
+                </div>
+            )}
+                        </div>
+
+            <span><button disabled={!ready}>{mode == modes.Undefined ? "Anchor or Validate" : mode}</button>
+                <button disabled={!files.length} onClick={clear}>Clear</button></span>
+        </div>
+    )
+}
+
+
+*/
+
+export {}
\ No newline at end of file
diff --git a/mereproof/src/components/MereProofDapp.tsx b/mereproof/src/components/MereProofDapp.tsx
new file mode 100644
index 0000000..346e6ee
--- /dev/null
+++ b/mereproof/src/components/MereProofDapp.tsx
@@ -0,0 +1,67 @@
+import React, { useCallback } from 'react'
+import { FC, useState } from 'react'
+import styles from '../styles/Home.module.css'
+import { TxStatus } from './TxStatus'
+import { useWallet } from '@alephium/web3-react'
+import { web3, node } from '@alephium/web3'
+import { MereProofConfig } from '@/services/utils'
+import { anchorHash } from '@/services/mereproof.service'
+//import { DropZone } from './DropZone'
+
+export const MereProofDapp: FC<{
+  config: MereProofConfig
+}> = ({ config }) => {
+  const { signer, account, explorerProvider, nodeProvider } = useWallet()
+
+  const [hash, setHash] = useState('de1ec7ab1e5e1ec7edc0ffee')
+  const [ongoingTxId, setOngoingTxId] = useState<string>()
+
+  const handleHashSubmit = async (e: React.FormEvent) => {
+
+    e.preventDefault()
+    if (nodeProvider) web3.setCurrentNodeProvider(nodeProvider)
+    if (signer) {
+      const result = await anchorHash(signer, account, hash) 
+      console.log(result)
+      setOngoingTxId(result.txId)
+    }
+  }
+
+  const txStatusCallback = useCallback(
+    async (status: node.TxStatus, numberOfChecks: number): Promise<any> => {
+      if ((status.type === 'Confirmed' && numberOfChecks > 2) || (status.type === 'TxNotFound' && numberOfChecks > 3)) {
+        setOngoingTxId(undefined)
+        console.log(status.type);
+      }
+
+      return Promise.resolve()
+    },
+    [setOngoingTxId]
+  )
+
+  console.log('ongoing..', ongoingTxId)
+  return (
+    <>
+     {ongoingTxId && <TxStatus txId={ongoingTxId} txStatusCallback={txStatusCallback} />}
+
+      <div className="columns">
+        <form onSubmit={handleHashSubmit}>
+          <>
+            <h2 className={styles.title}>Anchor hash on Alephium {config.network}</h2>
+            <p>PublicKey: {account?.publicKey ?? '???'}</p>
+            <label htmlFor="hash">Hash</label>
+            <input
+              type="string"
+              id="hash"
+              name="hash"
+              value={hash}
+              onChange={(e) => setHash(e.target.value)}
+            />
+            <br />
+            <input type="submit" disabled={!!ongoingTxId} value="Anchor hash" />
+          </>
+        </form>
+      </div>
+    </>
+  )
+}
diff --git a/mereproof/src/components/TokenDapp.tsx b/mereproof/src/components/TokenDapp.tsx
deleted file mode 100644
index d247b1b..0000000
--- a/mereproof/src/components/TokenDapp.tsx
+++ /dev/null
@@ -1,79 +0,0 @@
-import React, { useCallback } from 'react'
-import { FC, useState } from 'react'
-import styles from '../styles/Home.module.css'
-import { withdrawToken } from '@/services/token.service'
-import { TxStatus } from './TxStatus'
-import { useWallet } from '@alephium/web3-react'
-import { node } from '@alephium/web3'
-import { TokenFaucetConfig } from '@/services/utils'
-
-export const TokenDapp: FC<{
-  config: TokenFaucetConfig
-}> = ({ config }) => {
-  const { signer, account } = useWallet()
-  const addressGroup = config.groupIndex
-  const [withdrawAmount, setWithdrawAmount] = useState('')
-  const [ongoingTxId, setOngoingTxId] = useState<string>()
-
-  const handleWithdrawSubmit = async (e: React.FormEvent) => {
-    e.preventDefault()
-    if (signer) {
-      const result = await withdrawToken(signer, withdrawAmount, config.faucetTokenId)
-      setOngoingTxId(result.txId)
-    }
-  }
-
-  const txStatusCallback = useCallback(
-    async (status: node.TxStatus, numberOfChecks: number): Promise<any> => {
-      if ((status.type === 'Confirmed' && numberOfChecks > 2) || (status.type === 'TxNotFound' && numberOfChecks > 3)) {
-        setOngoingTxId(undefined)
-      }
-
-      return Promise.resolve()
-    },
-    [setOngoingTxId]
-  )
-
-  console.log('ongoing..', ongoingTxId)
-  return (
-    <>
-      {ongoingTxId && <TxStatus txId={ongoingTxId} txStatusCallback={txStatusCallback} />}
-
-      <div className="columns">
-        <form onSubmit={handleWithdrawSubmit}>
-          <>
-            <h2 className={styles.title}>Alephium Token Faucet on {config.network}</h2>
-            <p>PublicKey: {account?.publicKey ?? '???'}</p>
-            <p>Maximum 2 tokens can be withdrawn at a time.</p>
-            <table>
-              <thead>
-                <tr>
-                  <td>id</td>
-                  <th>group</th>
-                </tr>
-              </thead>
-              <tbody>
-                <tr key={addressGroup} style={{ background: 'red', color: 'white' }}>
-                  <td>{config.faucetTokenId}</td>
-                  <td>{addressGroup}</td>
-                </tr>
-              </tbody>
-            </table>
-            <label htmlFor="withdraw-amount">Amount</label>
-            <input
-              type="number"
-              id="transfer-amount"
-              name="amount"
-              max="2"
-              min="1"
-              value={withdrawAmount}
-              onChange={(e) => setWithdrawAmount(e.target.value)}
-            />
-            <br />
-            <input type="submit" disabled={!!ongoingTxId} value="Send Me Token" />
-          </>
-        </form>
-      </div>
-    </>
-  )
-}
diff --git a/mereproof/src/components/TxStatus.tsx b/mereproof/src/components/TxStatus.tsx
index a23fbe9..72185bf 100644
--- a/mereproof/src/components/TxStatus.tsx
+++ b/mereproof/src/components/TxStatus.tsx
@@ -1,6 +1,7 @@
 import React, { useCallback, useRef } from 'react'
 import { useTxStatus } from '@alephium/web3-react'
 import { node } from '@alephium/web3'
+import { useWallet } from '@alephium/web3-react'
 
 interface TxStatusAlertProps {
   txId: string
diff --git a/mereproof/src/pages/_app.tsx b/mereproof/src/pages/_app.tsx
index 0920d8e..123ba60 100644
--- a/mereproof/src/pages/_app.tsx
+++ b/mereproof/src/pages/_app.tsx
@@ -1,15 +1,19 @@
-import React from 'react'
+import React, { useState } from 'react'
 import '@/styles/globals.css'
 import type { AppProps } from 'next/app'
 import { AlephiumWalletProvider } from '@alephium/web3-react'
-import { tokenFaucetConfig } from '@/services/utils'
+import { mereProofConfig } from '@/services/utils'
+import { NetworkId } from '@alephium/web3';
+
 
 export default function App({ Component, pageProps }: AppProps) {
+
+  const [networkId, setNetworkId] = useState<NetworkId>(mereProofConfig.network);
+
   return (
     <AlephiumWalletProvider
       theme="web95"
-      network={tokenFaucetConfig.network}
-      addressGroup={tokenFaucetConfig.groupIndex}
+      network={networkId}
     >
       <Component {...pageProps} />
     </AlephiumWalletProvider>
diff --git a/mereproof/src/pages/index.tsx b/mereproof/src/pages/index.tsx
index baa16ec..45eb46c 100644
--- a/mereproof/src/pages/index.tsx
+++ b/mereproof/src/pages/index.tsx
@@ -1,9 +1,9 @@
 import React from 'react'
 import Head from 'next/head'
 import styles from '@/styles/Home.module.css'
-import { TokenDapp } from '@/components/TokenDapp'
+import { MereProofDapp } from '@/components/MereProofDapp'
 import { AlephiumConnectButton, useWallet } from '@alephium/web3-react'
-import { tokenFaucetConfig } from '@/services/utils'
+import { mereProofConfig } from '@/services/utils'
 
 export default function Home() {
   const { connectionStatus } = useWallet()
@@ -13,13 +13,13 @@ export default function Home() {
       <div className={styles.container}>
         <AlephiumConnectButton />
         <Head>
-          <title>Token Faucet</title>
+          <title>MereProof</title>
           <meta name="description" content="Generated by @alephium/cli init" />
           <meta name="viewport" content="width=device-width, initial-scale=1" />
           <link rel="icon" href="/favicon.ico" />
         </Head>
 
-        {connectionStatus === 'connected' && <TokenDapp config={tokenFaucetConfig} />}
+        {connectionStatus === 'connected' && <MereProofDapp config={mereProofConfig} />}
       </div>
     </>
   )
diff --git a/mereproof/src/services/mereproof.service.ts b/mereproof/src/services/mereproof.service.ts
new file mode 100644
index 0000000..7af5766
--- /dev/null
+++ b/mereproof/src/services/mereproof.service.ts
@@ -0,0 +1,18 @@
+import { DUST_AMOUNT, NodeProvider, ExplorerProvider, SignerProvider, Account, SignTransferTxResult } from '@alephium/web3'
+
+export const anchorHash = async (
+  signerProvider: SignerProvider,
+  account: Account,
+  hash: string,
+): Promise<SignTransferTxResult> => {
+  return await signerProvider.signAndSubmitTransferTx({
+    destinations: [
+      {
+        address: account.address,
+        attoAlphAmount: DUST_AMOUNT,
+        message: hash
+      }
+    ],
+    signerAddress: account.address
+  })
+}
diff --git a/mereproof/src/services/merkle.service.ts b/mereproof/src/services/merkle.service.ts
new file mode 100644
index 0000000..12a2990
--- /dev/null
+++ b/mereproof/src/services/merkle.service.ts
@@ -0,0 +1,279 @@
+/*
+* Copyright (c) 2018-2024 ALSENET SA
+*
+* Author(s):
+*
+*      Luc Deschenaux <luc.deschenaux@freesurf.ch>
+*
+* This program is free software: you can redistribute it and/or modify
+* it under the terms of the GNU Affero General Public License as published by
+* the Free Software Foundation, either version 3 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU Affero General Public License for more details.
+*
+* You should have received a copy of the GNU Affero General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*
+*/
+
+/*
+import { assert } from 'console';
+import { sha512, sha384, sha512_256, sha512_224, Hash, Message, Hasher } from 'js-sha512';
+
+export const mask: number = 0xfffe
+export var debug: boolean = false
+export const version: string = 'mereproof-0.0.1'
+export var defaultHashType: string = 'SHA512_256'
+
+export interface MerkleProof {
+  version?: string
+  hashType: string
+  root: string
+  hash: string
+  operations: Array<Operation>
+  anchors?: Array<Anchor>
+  date: string
+}
+
+interface Operation {
+  left?: string
+  right?: string
+}
+
+interface Anchor {
+  type: string
+  networkId: number
+  transactionId: string
+  blockId: string
+  blockDate: string
+}
+
+export interface TreeNode {
+  hash: number[]
+  proof?: MerkleProof
+}
+
+export type Tree = Array<Array<TreeNode>>
+
+export interface HashFunc<TValue> {
+  [id: string]: TValue
+}
+
+export var _digest: HashFunc<(message: Message) => number[]> = {
+  SHA512_256: sha512_256.digest,
+  SHA512_224: sha512_224.digest,
+  SHA512: sha512.digest,
+  SHA384: sha384.digest
+}
+
+export const digest = (data: Message, hashType?: string): Promise<number[]> => {
+  return new Promise((resolve, reject) => {
+    resolve(_digest[hashType || defaultHashType](data))
+  })
+}
+
+const hashToString = (hash: number[] | Uint8Array): string => {
+  return Array.prototype.slice.call(hash).map(value => ((value & 0xf0 ? '' : '0') + (value.toString(16)))).join('')
+}
+
+const stringToHash = (hash_str: string): Uint8Array => {
+  const a = hash_str.match(/.{2}/g) || [];
+  return new Uint8Array(a.map(byte => parseInt(byte, 16)))
+}
+
+const hashMerge = (hashLeft: Uint8Array | number[] | string, hashRight: Uint8Array | number[] | string, hashType: string): Promise<number[]> => {
+  if (typeof hashLeft == "string") {
+    hashLeft = stringToHash(hashLeft)
+  }
+  if (typeof hashRight == "string") {
+    hashRight = stringToHash(hashRight)
+  }
+  var result = new Uint8Array(hashLeft.length + hashRight.length)
+  result.set(hashLeft, 0)
+  result.set(hashRight, hashLeft.length)
+  return digest(result, hashType)
+}
+
+const compute = (objectList: Array<TreeNode>, hashType: string): Promise<Tree> => {
+  return computeTree(objectList, hashType)
+    .then((tree: Tree): Tree => {
+      computeProofs(tree, hashType)
+      return tree
+    })
+}
+
+const computeTree = (objectList: Array<TreeNode>, hashType: string): Promise<Tree> => {
+  return new Promise<Tree>((resolve, reject) => {
+    var leaves: TreeNode[] = [];
+    var tree: Tree = [leaves];
+
+    objectList.forEach(function (obj) {
+      leaves.push(obj);
+    });
+
+    if (leaves.length > (mask | 1)) {
+      reject(new Error('too much leaves'));
+      return;
+    }
+
+    (function outerLoop(tree) {
+      if (tree[0].length <= 1) {
+        resolve(tree);
+        return;
+      }
+      tree.unshift([]);
+
+      return new Promise<Tree>((resolve, reject) => {
+        (function loop(index) {
+          if (index >= tree[1].length) {
+            resolve(tree);
+            return;
+          }
+          var node = tree[1][index];
+          // not the last node ?
+          if ((index | 1) < tree[1].length) {
+            // merge hash with the next node hash
+            return hashMerge(node.hash, tree[1][index | 1].hash, hashType)
+              .then((hash) => {
+                tree[0].push({
+                  hash: hash
+                });
+                loop(index + 2);
+              })
+          } else {
+            // last node without sibling
+            if (index>0) {
+              // merge with the first node hash instead
+              return hashMerge(node.hash, tree[1][0].hash, hashType)
+              .then((hash) => {
+                tree[0].push({
+                  hash: hash
+                });
+                loop(index + 2);
+              })
+            } else {
+              // nothing to merge, store vanilla hash
+              tree[0].push({
+                hash: node.hash
+              });
+              loop(index + 2);
+            }
+          }
+        })(0);
+      })
+    })(tree);
+  })
+} // computeTree
+
+const computeProofs = (tree: Tree, hashType: string): void => {
+  var leaves = tree[tree.length - 1];
+  var date = (new Date()).toISOString();
+
+  // for each leaf of the merkle tree
+  leaves.some((leaf: TreeNode, leafIndex) => {
+
+    leaf.proof = {
+      version: version,
+      hashType: hashType,
+      hash: hashToString(leaf.hash),
+      root: hashToString(tree[0][0].hash),
+      date: date,
+      operations: []
+    }
+
+    // at the top level, the node index matches the leaf index 
+    var nodeIndex = leafIndex;
+
+    // loop from leaf to root+1 level of the merkle tree
+    for (var level = tree.length - 1; level >= 1; --level) {
+
+      // get the nodes at the current level
+      var here = tree[level];
+
+      if (nodeIndex & 1) {
+        // current node index is odd (last bit is 1)
+        // so it is the "right" part of the pair
+        // and we add the "left" part in the proof
+        leaf.proof.operations.push({
+          left: hashToString(here[nodeIndex & mask].hash)
+        });
+
+      } else {
+        // current node index is even (last bit is 0)
+        // so it is the "left" part of the pair
+        // and we add the "right" part in the proof if any
+        if ((nodeIndex | 1) < here.length) {
+          // not the last node, there is a "right one"
+          leaf.proof.operations.push({
+            right: hashToString(here[nodeIndex | 1].hash)
+          });
+        }
+      }
+      // down a level the node index has to be halved
+      nodeIndex = nodeIndex >> 1;
+    }
+  })
+
+  if (debug) {
+    leaves.some((leaf) => {
+      if (!leaf.proof)
+        console.log(leaf, 'missing proof !');
+      else
+        checkProof(leaf.proof)
+          .then(validated => console.log(leaf.proof, validated.toString()));
+    });
+  }
+} // computeProofs
+
+const checkProof = (proof: MerkleProof): Promise<boolean> => {
+  return new Promise<boolean>((resolve, reject) => {
+    if (
+      !proof
+      || !proof.operations
+      || !Array.isArray(proof.operations)
+      || !proof.root
+      || !proof.hash
+    ) return resolve(false);
+
+    debug && console.log(proof)
+
+    new Promise<number[]>((resolve, reject) => {
+      (function loop(hash: number[], i) {
+        if (debug)
+          console.log(hash)
+        if (i >= proof.operations.length)
+          return resolve(hash);
+
+        var step = proof.operations[i];
+        if (step.left)
+          hashMerge(step.left, hash, proof.hashType)
+            .then(hash => loop(hash, i + 1))
+            .catch(reject);
+
+        else
+          if (step.right)
+            hashMerge(hash, step.right, proof.hashType)
+            .then(hash => loop(hash, i + 1))
+            .catch(reject)
+
+          else
+            reject(new Error('invalid proof'));
+
+      })(stringToHash(proof.hash) as unknown as number[], 0);
+    })
+      .then(hash => resolve(hashToString(hash) == proof.root))
+      .catch(reject)
+  })
+
+} // checkProof
+
+const getRoot = (tree: Tree): string => {
+  return hashToString(tree[0][0].hash);
+}
+*/
+
+export {}
\ No newline at end of file
diff --git a/mereproof/src/services/token.service.ts b/mereproof/src/services/token.service.ts
deleted file mode 100644
index fcdc028..0000000
--- a/mereproof/src/services/token.service.ts
+++ /dev/null
@@ -1,16 +0,0 @@
-import { DUST_AMOUNT, ExecuteScriptResult, SignerProvider } from '@alephium/web3'
-import { Withdraw } from '../../artifacts/ts/scripts'
-
-export const withdrawToken = async (
-  signerProvider: SignerProvider,
-  amount: string,
-  tokenId: string
-): Promise<ExecuteScriptResult> => {
-  return await Withdraw.execute(signerProvider, {
-    initialFields: {
-      token: tokenId,
-      amount: BigInt(amount)
-    },
-    attoAlphAmount: DUST_AMOUNT
-  })
-}
diff --git a/mereproof/src/services/utils.tsx b/mereproof/src/services/utils.tsx
index 01b95a1..5043e49 100644
--- a/mereproof/src/services/utils.tsx
+++ b/mereproof/src/services/utils.tsx
@@ -1,25 +1,18 @@
 import { NetworkId } from '@alephium/web3'
-import { loadDeployments } from '../../artifacts/ts/deployments'
+// import { loadDeployments } from '../../artifacts/ts/deployments'
 
-export interface TokenFaucetConfig {
+export interface MereProofConfig {
   network: NetworkId
-  groupIndex: number
-  tokenFaucetAddress: string
-  faucetTokenId: string
 }
 
 function getNetwork(): NetworkId {
-  const network = (process.env.NEXT_PUBLIC_NETWORK ?? 'devnet') as NetworkId
+  const network = 'testnet' as NetworkId  // (process.env.NEXT_PUBLIC_NETWORK ?? 'devnet') as NetworkId
   return network
 }
 
-function getTokenFaucetConfig(): TokenFaucetConfig {
+function getMereProofConfig(): MereProofConfig {
   const network = getNetwork()
-  const tokenFaucet = loadDeployments(network).contracts.TokenFaucet.contractInstance
-  const groupIndex = tokenFaucet.groupIndex
-  const tokenFaucetAddress = tokenFaucet.address
-  const faucetTokenId = tokenFaucet.contractId
-  return { network, groupIndex, tokenFaucetAddress, faucetTokenId }
+  return { network }
 }
 
-export const tokenFaucetConfig = getTokenFaucetConfig()
+export const mereProofConfig = getMereProofConfig()
diff --git a/mereproof/src/styles/globals.css b/mereproof/src/styles/globals.css
index 4a7390b..4eba685 100644
--- a/mereproof/src/styles/globals.css
+++ b/mereproof/src/styles/globals.css
@@ -2,13 +2,131 @@
   box-sizing: border-box;
 }
 
+input#hash {
+  width: 100%;
+}
+ul.dropzone {
+  list-style: none;
+  height: 300px;
+  overflow: scroll;
+  padding-left: 0;
+}
+ul.dropzone {
+  list-style: none;
+  height: 300px;
+  overflow: scroll;
+  padding-left: 0;
+
+  li {
+    border: 1px solid black;
+    display: flex;
+    flex-direction: row;
+    align-items: center;
+    padding-left: 1.5em;
+    span {
+      overflow: hidden;
+    }
+    span {
+      width: 50%;
+    }
+
+    svg {
+      display: none;
+    }
+
+    .trash {
+      display: block;
+    }
+
+    svg {
+      margin-right: 0.5em;
+    }
+
+  }
+
+  li.file.unpaired {
+    padding-left: 0;
+
+    .unpaired-file {
+      display: inline;
+    }
+  }
+
+  li.proof.unpaired {
+    padding-left: 0;
+
+    .unpaired-proof {
+      display: inline;
+    }
+  }
+}
+
+div.DropZone {
+
+  button {
+    margin-right: 10px;
+  }
+
+  ul.dropzone {
+    list-style: none;
+    height: 300px;
+    overflow: scroll;
+    padding-left: 0;
+  
+    li {
+      border: 1px solid black;
+      display: flex;
+      flex-direction: row;
+      align-items: center;
+      padding-left: 1.5em;
+      span {
+        overflow: hidden;
+      }
+      span {
+        width: 50%;
+      }
+  
+      svg {
+        display: none;
+      }
+  
+      .trash {
+        display: block;
+      }
+  
+      svg {
+        margin-right: 0.5em;
+      }
+  
+    }
+  
+    li.file.unpaired {
+      padding-left: 0;
+  
+      .unpaired-file {
+        display: inline;
+      }
+    }
+  
+    li.proof.unpaired {
+      padding-left: 0;
+  
+      .unpaired-proof {
+        display: inline;
+      }
+    }
+  }
+  
+}
+
+
 .columns {
   display: flex;
   grid-template-columns: 1fr 1fr;
   column-gap: 2em;
 }
 
-.columns > * {
+.columns>* {
   flex-grow: 1;
 }
 
@@ -421,8 +539,8 @@ input[type="radio"] {
   display: inline-block;
 }
 
-input[type="checkbox"] + label,
-input[type="radio"] + label {
+input[type="checkbox"]+label,
+input[type="radio"]+label {
   display: inline-block;
   font-weight: normal;
   position: relative;
@@ -510,4 +628,4 @@ blockquote footer {
   font-size: small;
   line-height: var(--line-height);
   padding: 1.5rem 0;
-}
+}
\ No newline at end of file
